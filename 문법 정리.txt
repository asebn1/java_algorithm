### **String (String str = "123";)**

- str.length()
- str.indexOf("abc") : 없을 경우 -1 반환
    - str.indexOf("abc", i) : i번째 부터 문자열을 찾음
    - str.lastIndexOf("abc") : 가장 마지막에 일치하는 문자열 위치 반환
- str.substring(n) : n부터 끝까지 str 파싱
    - str.substring(n1, n2) : n1 부터 n2 -1 까지 str 파싱
- str1.compareTo(str2) : str1과 str2의 사전순 비교
    - str1 - str2라 생각해서 > 0 일 경우, str1이 사전적으로 더 큰 값(더 나중에 나오는 값) ex) "B" - "A" > 0
- str.replaceAll("before", "after") : 문자열 변경
    - str.replaceFirst("before", "after") : 첫번째로 찾은 문자열 변경
- str.trim() : 처음과 끝 공백 제거
- str.split(",") : ","을 기준으로 쪼개어 String[] 배열 반환
    - str.split("") 시 1개 문자씩 쪼개어짐
- String.join("", strArr) : String 배열을 "" 구분자로 합쳐줌
- str.toCharArray() : 문자열을 char Array로 변경해줌 ex) for(char c : str.toCharArray()) { // 코드 }

### **Character (char c = 'a';)** 

- Character.isDigit(c) : 숫자 true, 아니면 false
- Character.isAlphabetic(c) : 알파벳이면 true, 아니면 false

### **StringBuilder (StringBuilder sb = new StringBuilder(name))**

- sb.setCharAt(n, 'A') : n번째 인덱스의 문자를 'A'로 치환
- sb.deleteCharAt(n) : 특정 위치의 문자 삭제 가능
    - sb.deleteCharAt(n, m) : 범위 삭제로 가능
- sb.toString() : StringBuilder를 String으로 변환

### **List (List list = new ArrayList<>();)**

- list.get(i)
- list.set(i, T)
- list.size()
- Collections.sort(list) : 오름차순 정렬
    - Collections.sort(list, Collections.reverseOrder()) : 내림차순 정렬
    - new Comparator()을 통해 list 내 객체 간 정렬 가능

```java
`Collections.sort(list, new Comparator(){
    @Override
    public int compare(Object o1, Object o2){ // Obejct로 써야 함
	if( ((Book)o1).id > ((Book)o2). id){  // 사용시 (Book) 등으로 캐스팅 후 사용
	    return 1;
	}
	else {
	    return -1;
	}
    }
)`
```

```java
// 람다식 사용 방법
Collections.sort(list, (o1, o2) -> {
    return (o1.length > o2.length) ? 1 : -1;
});
```

**Array (int[] arr= new int[size];)**

- arr.length
- arr[i]
- Arrays.sort(arr) : 오름차순 정렬
    - Arrays.sort(arr,Collections.reverseOrder()) // 내림차순 정렬
    - new Comparator()을 통해 arr 내 객체 간 정렬 가능

```java
Arrays.sort(arr, new Comparator(){
    @Override
    public int compare(Object o1, Object o2){
	if(o1.id > o2. id){
	    return 1;
	}
	else {
	    return -1;
	}
    }
)
```

Arrays.copyOfRange(arr, n, m) : arr 배열의 n부터 m-1까지 복사후 반환

- Arrays.fill(arr, 101) : 101로 배열의 모든 값을 채움
- Arrays.binarySearch(arr, value) : 이진 탐색 라이브러리 // 라이브러리여도 arr를 오름차순으로 sort 후 사용해줘 함
    - 값이 없을 경우, 음수를 반환함

### **Queue (Queue queue = new LinkedList<>();)**

> Class와 함께 쓰면, Queue 안에 내용을 업데이트 하면서 사용할 수 있음 ex) for(Work work : queue) { work.update(); }
> 
- queue.offer(T) : 데이터 추가
- queue.poll() : 첫번째 데이터 삭제 후 반환
- queue.peek() : 첫번째 데이터 값 조회
- queue.isEmpty()
- queue.clear()
- PriorityQueue priorityQueue = new PriorityQueue<>() : 우선순위 큐 (작은 값 우선)
    - 내부적으로 Heap의 구조를 가지고 있음
    - 삽입 시간 O(logN), 삭제 시간O(logN) => 정렬하는 시간 복잡도 NlogN
    - 많은 양의 데이터(ex. 1,000,000 이상)를 다룰 때, 좋은 속도(성능)를 보여줌
    - PriorityQueue priorityQueue = new PriorityQueue<>(Collections.reverseOrder()); // maxHeap 구조(큰 값 우선)

### **Stack (Stack stack = new Stack<>();)**

- stack.push(T)
- stack.pop()
- stack.peek() : 마지막 데이터 값 조회
- stack.isEmpty()
- stack.search(T) : 몇번 pop 해야 T값이 나오는지 확인
- stack.clear()

### **HashMap (HashMap<String, Integer> map = new HashMap<>();)**

> Key 값을 int 형식의 해시값 나누어서 저장, 탐색하기 때문에, 검색 속도 ArrayList 보다 평균적으로 좋음. 검색해야하는 수가 많을 경우(ex. 0 <= n <= 1,000,000) 이상일 경우 고려해보기
> 
- map.put("abc", n) : "abc"라는 key와 n이라는 value로 map의 업데이트(없을 시 추가, 있을 시 key에 해당하는 value 업데이트)
- map.get(key) : key에 해당하는 value를 반환(없을 경우, null 반환)
    - map.getOrDefault(key, 0) : 반환 시 초기 값 지정 ex) map.put("abc", map.getOrDefault("abc", 0) + 1)
- map.remove(key) : key에 해당하는 데이터 삭제
- map.containsKey(temp) : temp라는 키가 map에 존재하는지 반환(있을 시 true)
- map.keySet() : map의 key들을 전부 반환 ex) for(String key : map.keySet())
- for(Map.Entry<String, String> entry : map.entrySet()) { // 코드 } : keySet으로 key, value를 따로 호출하는 것보다 더 빠름
    - entry.getKey(), entry.getValue() : key와 value를 반환

### **Set (HashSet set = new HashSet<>();)**

> 중복제거를 알아서 해줌.
> 
- set.add("a") : 기존 HashSet에 a가 들어있을 시, false를 반환하기 때문에 중복 값이 있는지 확인할 경우 유용하게 사용
- set.size()
- set.clear()

### **Math**

- Math.pow(2, 3) : 거듭제곱
- Math.max(a, b) : 최댓값
    - Math.max(a, Math.max(b, c)) 이런 식으로 하면 3개 중의 최댓값을 찾는데 사용
- Max.abs(-3) : 절대값 반환